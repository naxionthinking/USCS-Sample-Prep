---
title: "USCS Prep Sample for Qualtrics 1"
output:
  html_document:
    df_print: paged
editor_options:
  markdown:
    wrap: 75
---

### Preparatory Steps

Consult `ReadMe.md` for instructions on how to configure the inputs
properly before running this script


Remember to update file paths and variables in `Config_and_Helper.R`

 **This code will output warnings and messages.** The warnings indicate
    a check is not met. These will be printouts with "Warning:" before
    them. If a check is passed, a message will be printed with "SUCCESS:"
    before it. If any warnings are printed, figure out why and report if
    the warning says to.

### Dependencies

```{r Load in Packages, message=FALSE, warning=FALSE}
if (!require("pacman")) install.packages("pacman")

# Loads in necessary packages, and installs them if you don't have them installed
pacman::p_load("tidyverse",
               "readxl",
               "stringi",
               "varhandle",
               "openxlsx")

# Load in configuration file variables and functions
source('Config_and_Helpers.R') 

options(scipen = 99999, # Remove scientific notation
        dplyr.summarise.inform = FALSE) # Remove summarize messages

knitr::opts_chunk$set(results = "asis", # Prints html tables nicely
                      echo=TRUE) # Show all code chunks in the output

output_wb <- createWorkbook()
```

### Data Loading

```{r Load in base and spend dataframes}
all_base <- load_base() 
all_spend <- load_spend()

f_str("There were {format(nrow(all_base), big.mark = ',')} observations loaded in for BASE") %>% message()
f_str("There were {format(nrow(all_spend),big.mark = ',')} observations loaded in for SPEND") %>% message()
```

```{r Missing Value Summary}
# Variables to summarize number of missing values
miss_vars <- c("first_nm", 
               'last_nm',
               "raw_fico",
               "fico_range",
               "raw_age",
               "share_of_wallet_amex",
               "size_of_wallet",
               "customer_spend",
               "account_spend")

# Number and Percent of missing values for key variables
miss_vals <- all_base %>%
  select(all_of(miss_vars)) %>%
  summarise_all(~sum(is.na(.))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "n_missing") %>%
  mutate("Percent Missing" = paste0(round(n_missing / nrow(all_base) * 100, 4), " %")) %>% 
  arrange(desc(n_missing)) %>% make_nice_table("Number of Missing Values per Key Variable")
```


```{r Filtering base and spend}
# Change these monthly based on OPS instructions
# Comment out filters that do not need to be applied

all_base <- all_base %>% 
  # *Change new_smart_rev to numeric
  #mutate(new_smart_rev = as.numeric(new_smart_rev_char)) %>%
  
  #*From Ops email: (please take out all counts for Augment 54);
  # filter(!cell_code %in% c("","CNGR54")) %>% 
  #*from ops email 9 28 22: #take out the three people missing marketer_code
  filter(marketer_code != "") 

all_spend <- all_spend %>%
  rename(gmpi_base_cust_id = customer_id) %>% 
  # Remove records with blank space at start of ID
  filter(substring(gmpi_base_cust_id, 1, 1) != " ") 
```


### Cell Code Checking

-   Compare the total amount of main sample received to the amount of
    sample requested
-   Verify no missing cell codes

```{r Check Cell Codes, message=FALSE}
# Create a frequency table of each cell code
cell_code_freq <- all_base %>% 
  freq_table("cell_code", caption = "Cell Code Frequencies")
```

```{r }
# Break the cell codes into the main survey codes and augmented survey codes
# Main Survey has 'Cell_Codes' that start with 'CCSG' 
main_survey_ccs <- cell_code_freq %>% filter(str_starts(cell_code, "CCSG")) 
aug_survey_ccs <- cell_code_freq %>% 
  filter(!str_starts(cell_code, "CCSG") & str_starts(cell_code, "C"))
```

```{r message=FALSE}
# Load in the expected frequencies from the helper file
req_sp_codes <- read_excel(SAMPLE_PREP_PATH,
                           sheet = "Sp_Code_Freqs") %>% 
  set_names(c("sp_code", "card_name", "Total")) %>% 
  mutate(sp_code = glue("SP{sp_code}")) %>% 
  drop_na(sp_code)
```

```{r}
if (sum(main_survey_ccs$Freq) != sum(req_sp_codes$Total)){
  warning("The Main sample recieved does not match the sample requested
          Provide an explanation or resolution to the difference. Figure out what's wrong.")
} else{
  message("SUCCESS: The size of the main Sample recieved matches the sample requested")
}

missing_ccs <- cell_code_freq %>% dplyr::select(cell_code) %>% 
  filter(!cell_code %in% unique(c(main_survey_ccs$cell_code,
                                  aug_survey_ccs$cell_code)))

if (nrow(missing_ccs) > 0) {
  warning("Cell Code detected not in main or augmented survey detected. Check MISSING_CCS dataframe for these codes")
} else{
  message("SUCCESS: All cell codes match format for main or augmented surveys")
}
```

### Check to make sure everyone has a spend and tenure and new-product-tenure.

-   cell_code 68 can have any marketer code but if it does have 135, notify
    PM

```{r}
# Check missing account spend and tenure add
acct_spend_add_t_NAs <- all_base %>% dplyr::select(account_spend, t_add) %>% 
  sapply(function(x) sum(is.na(x))) %>% as.data.frame() %>% 
  set_names("No. Missing Values")

acct_spend_add_t_NAs_tab <- acct_spend_add_t_NAs %>% 
  make_nice_table("Missing Values Account Spend and Tenure Add") 

if(acct_spend_add_t_NAs["account_spend",] > 0){
  warning("ACCOUNT SPEND has missing values")
} else{
  message("SUCCESS: ACCOUNT SPEND does not have missing values")
}

if(acct_spend_add_t_NAs["t_add",] > 0){
  warning("New Product Tenure has missing values")
}else{
  message("SUCCESS: New Product Tenure does not have missing values")
}
# Check missing set up dates
miss_setup_dt <- all_base[all_base$setup_dt == "",]
if (nrow(miss_setup_dt) > 0){
  warning("Missing Set up Date. Check miss_setup_dt variable")
}else{
  message("SUCCESS: No missing set up dates")
}

# Check missing marketer codes
miss_marketer_code <- all_base[all_base$marketer_code == "",]
if (nrow(miss_marketer_code) > 0){
  warning("Missing Marketer Code. Check miss_marketer_code variable")
}else{
  message("SUCCESS: No missing marketer codes")
}

cn68_market_codes <- all_base[all_base$cell_code == 'CN68',] %>% 
  dplyr::select(cell_code, marketer_code) %>% 
  mutate(is_not_sp135 = marketer_code != "SP135")

if (nrow(cn68_market_codes) > 0){
  warning("There are observations with Cell Code 'CN68'")
  if (sum(cn68_market_codes$is_not_sp135) > 0){
  warning("Not all marketer codes are SP135 for cell codes CN68. Alert OPS/PM") 
  } else {
    message("ITS OKAY because all marketer codes are SP135")
  }
} else{
    message("SUCCESS: No observations with Cell Code 'CN68'")
  }
```

**ACTION NEEDED**

-   The next two chunks output two excel sheets to be sent to the operations
    manager in an email. A third sheet is added later with removed tenure and spend as well.

    -   Excel sheet `Main_Code_Freqs` is found in the
        `Files_to_send/USCS_Diagnostics_MONTH_YEAR.xlsx` file

    -   Excel Sheet `Cell_Code_Freqs` is found in the
        `Files_to_send/USCS_Diagnostics_MONTH_YEAR.xlsx` file

```{r }
# Table with marketer code frequencies for cell codes "CCSG01", "CCSG02", "CCSG03"
main_code_freq <- all_base %>% 
  filter(cell_code %in% c("CCSG01", "CCSG02", "CCSG03")) %>% 
  freq_table("marketer_code", 
             caption = "Marketer Code Frequencies for Main Cell Codes")

# Write to excel to send to OPS Manager
addWorksheet(output_wb, "Main_Code_Freqs")
writeData(output_wb, "Main_Code_Freqs", main_code_freq)
```

```{r}
cell_code_freq <- cell_code_freq %>% 
  # Extract two digit number from cell code and append it to either Drop or Augment
  mutate(naw_cell_code = if_else(str_starts(cell_code, "CCS"),
                                 paste("CCSG DROP", 
                                        str_extract(cell_code, "[0-9]{2}")),
                                 paste("Augment Cell",
                                       str_extract(cell_code, "[0-9]{2}")))
         ) %>% 
  dplyr::select(cell_code, naw_cell_code, Freq) %>% 
  arrange(str_extract(cell_code, "[0-9]{2}"))

# Save to output excel file to be sent to PM
addWorksheet(output_wb, "Cell_Code_Freqs")
writeData(output_wb, "Cell_Code_Freqs", cell_code_freq)

ccf <- cell_code_freq %>% 
  make_nice_table("Cell Code Frequencies with NAW Cell Codes")

saveWorkbook(output_wb, file = f_str("../Files_to_send/USCS_Diagnostics_{MONTH}_{YEAR}.xlsx"), overwrite = TRUE)
```

### Check validity of userID and password

```{r}
invalid <- all_base %>% 
  dplyr::select(account_number, personalization1, personalization2) %>% 
  mutate(new_user_id = gsub("  ", "", personalization1) %>% trimws(), # Remove double spaces and surrounding white space from username
         new_password = gsub("  ", "", personalization2) %>% trimws(),  # Remove double spaces and surrounding white space from password
         VALID = case_when(
           # Missing Value
           new_user_id == "" | new_password == "" ~ 1, 
           # Wrong Length
           nchar(new_user_id) != 7 | nchar(new_password) != 8 ~ 2,
           # First character of ID not 'u'
           substr(new_user_id, 1, 1) != 'u' ~ 3, 
           # userID should be all digits and password should be characters
           !(substr(new_user_id, 2, 7) %>% is_numbers_only() & 
               new_password %>% is_letters_only) ~ 4, 
           TRUE ~ 0) # If none of the above cases, it's valid
         ) %>% 
  filter(VALID != 0) # Remove all valid cases

if (nrow(invalid) > 0){
  warning("Some invalid passwords or usernames found. Report to Manager")
  invalid %>% make_nice_table("Invalid Usernames and Passwords")
} else{
  message("SUCCESS: All passwords and usernames valid")
}
```

### Check for duplicates

```{r}
all_base_dupes <- all_base[duplicated(all_base$gmpi_base_cust_id),]
all_spend_dupes <- all_spend[duplicated(all_spend$gmpi_base_cust_id),]

if (nrow(all_base_dupes) > 0){
  warning("Duplicate Base customer IDs in the Allbase dataframe")
  print(all_base_dupes$gmpi_base_cust_id)
} else{
  message("SUCCESS: No duplicates in Allbase dataframe")}

if (nrow(all_spend_dupes) > 0){
  warning("Duplicate base customer IDs in the Allspend dataframe")
  print(all_spend_dupes$gmpi_base_cust_id)
} else{
  message("SUCCESS: No duplicates in Allspend dataframe")}
```

### Merge Allspend and Allbase

-   Code to account for the all Augments when assigning values to
    'naw_cell_code'
-   Add code for new Augments
-   Make sure the proper number of records remain

```{r}
all <- inner_join(all_base, all_spend, by = "gmpi_base_cust_id") %>% 
  mutate(setup_year = substr(setup_dt, 1, 4) %>% as.numeric(),
         setup_month = substr(setup_dt, 6,7) %>% as.numeric(),
         tenure_var = 12*(YEAR-1-setup_year)+(MONTH_NO+12-setup_month),
         account_spend = as.numeric(account_spend),
         tenure_cat = case_when(
           tenure_var <   5 ~ 1,
           tenure_var <  16 ~ 2,
           tenure_var <  25 ~ 3,
           tenure_var <  49 ~ 4,
           tenure_var <  73 ~ 5,
           tenure_var < 109 ~ 6,
           tenure_var < 145 ~ 7,
           tenure_var < 181 ~ 8,
           tenure_var < 241 ~ 9,
           TRUE ~ 10),
         
         spend = case_when(
           account_spend <=    0 ~ "A",
           account_spend <  1500 ~ "B",
           account_spend <  2500 ~ "C",
           account_spend <  5000 ~ "D",
           account_spend <  7500 ~ "E",
           account_spend < 10000 ~ "F",
           account_spend < 20000 ~ "G",
           account_spend < 35000 ~ "H",
           account_spend < 50000 ~ "I",
           TRUE ~ "J"),
         
         top_spender = if_else(account_spend < 50000, 0, 1),
         # Spend cat3 is the numeric value of the account spend's alphabet positions (A:1, B:2 ... J:10)
         spend_cat3 = match(spend, LETTERS), 
         
         naw_cell_code = if_else(str_starts(cell_code, "CCSG"),
                                 gsub("CCSG", "DROP", cell_code),
                                 gsub("[A-Z]{2,}", "CELL", cell_code)),
         
         naw_type = if_else(cell_code %in% c("CCSG01", "CCSG02", "CCSG03"),
                            "MAIN",
                            "AUGMENT")
         )


if (nrow(all) != nrow(all_base)){
  warning("Size of merged dataframe does not match original dataframe.")
} else{
  message("SUCCESS: Size of merged dataframe matches original dataframe")
}

```

```{r}
# Save datasets and remove from memory
all_base %>% write_csv("../Data/all_base_{MONTH}_{YEAR}.csv" %>% f_str(), na ="")
all_spend %>% write_csv("../Data/all_spend_{MONTH}_{YEAR}.csv" %>% f_str(), na ="")
#rm(all_base, all_spend) # Uncomment this to remove all_base and all_spend
```

### Checking for Duplicate Keys in Merged Data frame

```{r message=FALSE}
# First checking distribution of sample by Augment/MAIN;
naw_freq_table <- all %>%
  freq_table(c("naw_type", "naw_cell_code"),
             caption="Naw Type vs Naw Cell Code Frequencies")
```

```{r }
# Identify duplicates for customer id and username/password
cust_id_dupes <- all[duplicated(all$gmpi_base_cust_id),]
pers_dupes <- all[duplicated(all[,c("personalization1", "personalization2")]),]

if (nrow(cust_id_dupes) > 0){
  warning("There are customer ID duplicates in the merged dataframe")
  print(cust_id_dupes$gmpi_base_cust_id)
} else{
  message("SUCCESS: No Customer ID duplicates in the merged dataframe")
}

if (nrow(pers_dupes) > 0){
  warning("There are userID/password duplicates in the merged dataframe")
  print(pers_dupes[,c("personalization1", "personalization2")])
} else{
  message("SUCCESS: No userID/password duplicates in the merged dataframe")
}
```

### DMA Frequency

-   Make sure all DMA Codes are valid using the `DMA_Checks` sheet of the
    sample prep excel file.

```{r message=FALSE}
# Load in valid dmas
valid_dmas <- read_excel(SAMPLE_PREP_PATH,
                         sheet = "Valid_DMA_Codes") %>% 
  pull(Valid_DMA)
```

```{r }
# identify invalid dma's if any and get frequencies
invalid_dmas <- all %>% filter(!best_dma_cd %in% valid_dmas) %>% group_by(best_dma_cd) %>% summarize(n = n()) 

if (nrow(invalid_dmas) > 0){
  warning("There are invlaid DMA Codes in the file. Here are the codes and number of occurrences:")
  invalid_dmas %>% make_nice_table("Invalid DMA Code Frequencies") 
} else{
  message("SUCCESS: No invalid DMAs found in file")
}
```

### Frequency Tables for Spend and Tenure

-   Split the sample into Main and Augment

-   Frequency tables of spend tenure categories, and tenure_var for main
    samples

```{r}
# Split dataframe into main and augmented
main <- all %>% filter(naw_type == "MAIN") %>% 
  mutate(customer_id = gmpi_base_cust_id %>% as.numeric())
augment <- all %>% filter(naw_type == "AUGMENT")

```

```{r}
spend_freq_table <- main %>% 
  freq_table("spend", caption="Spend Category Frequencies")

tenure_freq_table <- main %>% 
  freq_table("tenure_cat", caption="Tenure Category Frequencies")

spend_freq_table_cat1 <- main %>% 
  filter(tenure_cat == 1) %>%
  freq_table("spend", caption="Spend Category Freqs for Tenure Category 1")

tenure_freq_table_cat1 <- main %>% 
  filter(tenure_cat == 1) %>% 
  freq_table("tenure_var", caption="Tenure Var Frequencies for Tenure Category 1")
```

### Sp Code Checking

-   Compare totals for desired sp codes to requested sp code totals

```{r}
main_sp_codes <- main %>% 
  freq_table("marketer_code", caption = "Sp Code Frequencies")
```

```{r}
# Check if the requested totals for each code matches the observed total
check_sp_codes <- main_sp_codes %>% 
  dplyr::select(marketer_code, Freq) %>% 
  left_join(req_sp_codes, by = c("marketer_code" = "sp_code")) %>% 
  mutate(difference = abs(Freq - Total)) %>% # This difference should be 0
  rename(Obs_Freq = Freq, Req_Freq = Total)


if (sum(check_sp_codes$difference) > 0){
  warning("Frequencies of Observed Sp Codes do not match requested totals for the following codes")
  print(check_sp_codes %>% filter(difference > 0))
} else{
  message("SUCCESS: All observed frequencies of sp codes match requested totals. ")
}
```

-   Ensure Requested Sp Codes do not have spending category A.
  - Is there anyone with spend <= 0 that shouldnâ€™t be?
  - Are there products that can have spend <= 0 that have no observations with spend <= 0?


```{r}
# The sp codes below should not have SPEND <= 0;
sp_code_no_a <- c("SP111",
                  "SP112",
                  "SP113",
                  "SP114",
                  "SP115",
                  "SP117",
                  "SP118",
                  "SP123",
                  "SP127",
                  "SP132",
                  "SP136",
                  "SP145",
                  "SP153",
                  "SP156") # SP 156 added in JULY 2018

# Sp codes that are allowed to have no or negative spend
sp_code_a <- main$marketer_code[!main$marketer_code %in% sp_code_no_a] %>% unique()

# Sp codes observed to have spend <= 0
obs_sp_code_a <- main[main$spend == "A",]$marketer_code %>% unique()

# Identify if sp codes that should not have no spend have no spend
wrong_no_spends <- sp_code_no_a[sp_code_no_a %in% obs_sp_code_a]

# Identify if sp_codes that can have no spend have observation with no spend
missing_no_spends <- sp_code_a[!sp_code_a %in% obs_sp_code_a]

if (length(wrong_no_spends) > 0) {
  for (code in wrong_no_spends) {
    warning("Sp Code: {code} has spend <= 0 when it should not" %>% f_str())
    cat("\n")}
  warning("Alert Operations for confirmation to exclude them") # This is not in the code and would need to be added
} else{
  message("SUCCESS: All SP Codes who should not have spend <= 0, do not have spend <= 0")
} 


if (length(missing_no_spends) > 0) {
  for (code in missing_no_spends) {
    warning("Sp Code: {code} has no observations spend <= 0 when it is allowed too" %>% f_str())
    cat("\n")}
  warning("Check the UC file to see what proportion of the pre and post suppression counts are for $0 spend on that product.  Given the sample request, how likely is it that we received no $0 spenders? If it seems unreasonable, you should discuss the matter with operations")
} else{
  message("SUCCESS: All SP Codes who can have spend <= 0, have observations with spend <= 0")
} 
```


### New Open Segment

-   New Open Segment file received every May/June

-   The code reads in a list customer_ids classified segments.

-   No one in the Main sample should be in this file. The dataset that is
    created in the merge in the last step should have no records.

    -   If someone appears here, note and resolve/explain the issue

```{r message=FALSE}
# Load in new segment data
open_seg <- read_csv(OPEN_SEG_PATH) %>% 
  rename(gmpi_base_cust_id = cust_xref_id) %>% 
  mutate(customer_id = gmpi_base_cust_id %>% as.numeric()) # Get numeric ID
```

```{r}
# check distributions

# Customer ID Distribution in Main
cid_main <- main %>% 
  dplyr::select(customer_id_main = customer_id) %>% 
  summary() %>% make_nice_table("Customer ID Main Descriptive Stats")

# Open Segment Customer ID Distribution
cid_open <- open_seg %>%  
  dplyr::select(customer_id_open_seg = customer_id) %>% 
  summary() %>% make_nice_table("Customer ID Open Segment Descriptive Stats")

open_seg_freq <- open_seg %>% 
  freq_table("OPEN_MANAGED_SEGMENT", caption="Open Managed Segment Freqs")

open_seg_dupes <- open_seg[duplicated(open_seg$customer_id),]

if (nrow(open_seg_dupes) > 0){
  warning("Duplicated Customer IDs in New Open Segment File")
} else{
  message("SUCCESS: NO Duplicated Customer IDs in New Open Segment File")
}
```

```{r}
# Check if someone in the main file is in the open segment file
open_seg_check <- main %>% 
  inner_join(open_seg, by = c("gmpi_base_cust_id", "customer_id"))

if (nrow(open_seg_check) > 0){
  warning("Customers in the main file appear in the new segment file")
  cat('\n')
  if (nrow(open_seg_check) > 3000){
    warning("More than 3000 main file customers appear in the new segment. REPORT")
  } else{
   message("Less than 3000 main file customers appear in the new segment. Note and explain these customers. No need to report")
  }
} else{
  message("SUCCESS: No main file customers appear in the new segment")
}
```

```{r }
# Generate count for early and non-early tenure
et_tab <- main %>% 
  count(marketer_code, tenure_cat) %>%
  spread(tenure_cat, n, fill = 0)

et_tab <- et_tab %>% 
  # Create new variables for the split of early and non-early tenure counts
  mutate(et = `1`,
         non_et = rowSums(et_tab[3:11])) %>% 
  dplyr::select(marketer_code, et, non_et) %>% 
  janitor::adorn_totals('row') %>% 
  make_nice_table("Early vs Non-Early Tenure by SP Code")
```

### Diagnostic Tests

-   Keeping the 'Selected' functionality in for now.

```{r}
mrktr_naw <- table(main$marketer_code, main$naw_cell_code) %>%
  make_nice_table("Marketer Code vs NAw Cell Code")

main <- main %>% mutate(selected = 0,
                           # Extract marketer code (i.e. 101 from SP101)
                          sp_code = str_extract(marketer_code, "[0-9]{3}") %>% 
                            as.numeric(),
                           # Extract drop code (i.e. 1 from DROP 01)
                          drop_code = str_extract(naw_cell_code, "[0-9]{2}") %>% 
                            as.numeric(),
                          mv_nps_ind = if_else(selected == 0, "NPS", "MV"),
                          mr_in_n = if_else(mr_in == 'Y', 1, 2),
                          subject_line = if_else(selected == 0, 6, 7))
```

```{r }
write_csv(all, "../Data/all_{MONTH}_{YEAR}.csv" %>% f_str(), na ="")
write_csv(main, "../Data/main_{MONTH}_{YEAR}.csv" %>% f_str(), na ="")
```

```{r}
mr_in_ct <- table(main$mr_in,main$mr_in_n)

if (mr_in_ct[1,1] == 0 & mr_in_ct[2,2] == 0){
  message("SUCCESS: MR IN split worked correctly")
} else{
  warning("MR IN split did not work correctly.")}
```

# Augment Checking

```{r}
augment <- augment %>% filter(!marketer_code %in% c("", "SP138", "SP139")) %>% 
  mutate(customer_id = gmpi_base_cust_id %>% as.numeric())

cell_code_naw_sp_ct <- augment %>% 
  freq_table(c("naw_cell_code", "cell_code", "marketer_code"), 
             caption="Naw Cell Code vs Cell Code vs Sp Code Frequencies")
```

```{r}
# Check if someone in the augmented file is in the open segment file
open_seg_check_aug <- augment %>% 
  inner_join(open_seg, by = c("gmpi_base_cust_id", "customer_id"))

if (nrow(open_seg_check_aug) > 0){
  warning("Customers in the augmented file appear in the new segment file")
  cat('\n')
  if (nrow(open_seg_check_aug) > 3000){
    warning("More than 3000 augmented file customers appear in the new segment. REPORT")
  } else{
   message("Less than 3000 augmented file customers appear in the new segment. Note and explain these customers. No need to report")
  }
} else{
  message("SUCCESS: No augmented file customers appear in the new segment")
}
```

```{r}
# Add the open segment info to the augment file
augment <- augment %>% 
  left_join(open_seg, by = c("gmpi_base_cust_id", "customer_id"))
```

### Removing Bad Spend and Tenure in the Augment File

-   Checking expected specs to actual specs for augmented data.

-   Expected specs found in `Sample_Prep_Helper.xlsx` sheet *Augment_Specs*

-   Check tenure category and var Frequency to make sure they align with
    the expected specs

    -   Note errors
    -   Any deletions will be put into the `Files_to_send/USCS_Diagnostics_MONTH_YEAR.xlsx` file
      - Sheet named "Removed_Tenure_or_Spend"
      - Note this sheet will be empty if there are no observations removed

```{r message=FALSE}
exp_cell_codes <- read_excel(SAMPLE_PREP_PATH,
                             sheet = "Augment_Specs")
```

```{r}
tenure_spend_check <- augment %>% 
  dplyr::select(gmpi_base_cust_id, naw_cell_code, tenure_var, 
                      account_spend, marketer_code, setup_dt) %>%  
  inner_join(exp_cell_codes, by="naw_cell_code")  %>% 
  mutate(tenure_var_max = if_else(is.na(tenure_var_max), Inf, tenure_var_max),
         flag_tenure = tenure_var < tenure_var_min | tenure_var > tenure_var_max,
         flag_spend = (account_spend <= 0 & min_spend == ">$0")) %>% 
  filter(flag_spend | flag_tenure)


if (nrow(tenure_spend_check) > 0){
  warning(f_str("There are {nrow(tenure_spend_check)} people deleted in the augment file due to bad account spends or tenures. These will be found in the `Files_to_send/USCS_Diagnostics_MONTH_YEAR.xlsx` file"))
  augment <- augment %>% anti_join(tenure_spend_check, by = "gmpi_base_cust_id")
} else{
  message("SUCCESS: NO people deleted due to bad account spends or tenure in the augment file")
}
 
addWorksheet(output_wb, "Removed_Tenure_or_Spend")
writeData(output_wb, "Removed_Tenure_or_Spend", tenure_spend_check) 
saveWorkbook(output_wb, file = f_str("../Files_to_send/USCS_Diagnostics_{MONTH}_{YEAR}.xlsx"), overwrite = TRUE)
```

```{r SUBJECT LINE}
# perform ab split (if desired)
# makes new variables based on split
# The create_ab_split function will create the "selected" variable. So if you are performing the ab_split, remove the line that defaults the selected variable to 0.
augment <- augment %>% 
  #create_ab_split(strat_var = 'marketer_code', sample_size = 0.5) %>% # Stratify sample 50% of obs for each marketer code
  mutate(selected = 0) %>% # comment this out if using the ab_split
  mutate(sp_code = parse_number(marketer_code),
         mv_nps_ind = if_else(selected == 0, "NPS", "MV"),
         mr_in_n = if_else(mr_in == 'Y', 1, 2),
         subject_line = if_else(selected == 0, 6, 7)) # Change if PM instructs to

ncc_mv_nps <- augment %>% freq_table(c("naw_cell_code", "mv_nps_ind"),
                          "naw cell code vs MV NPS IND Freqs")
```

```{r}
sel_sbj_line <- augment %>%
  freq_table(c("selected", "subject_line"), "Selected vs Subject Line Freqs")
```

```{r}
# Store important sample datasets for the second script.
save(augment, main, file=f_str("../Data/unweighted_samples_{MONTH}_{YEAR}.Rdata"))
```

```{r message=FALSE}
# IF YOU ARE RUNNING `USCS_Weighting.Rmd` right after this, run this chunk and then you DO NOT have to reload in the data with the step `load(f_str("../Data/unweighted_samples_{MONTH}_{YEAR}.Rdata"))`
# There's no harm if you do, but the dataframes you need will stay in your environment

rm.all.but(keep = c('main', 'augment'))
```
